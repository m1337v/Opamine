#include <stdio.h>
#include <syslog.h>
#import <mach-o/loader.h>
#import <Foundation/Foundation.h>
#import <libjailbreak/libjailbreak.h>

#include <spawn.h>
#define POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 1
extern int posix_spawnattr_set_persona_np(const posix_spawnattr_t* __restrict, uid_t, uint32_t);
extern int posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t* __restrict, uid_t);
extern int posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t* __restrict, uid_t);

extern char*const* environ;

pid_t serverPid;
int serverInputPipe[2];
int serverOutputPipe[2];

#define SERVER_INPUT_FD 5
#define SERVER_OUTPUT_FD 6

bool stdout_log = false;
void SYSLOG(const char* fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    
    if(stdout_log) {
        vprintf(fmt, va);
    }
    
    openlog("palera1n",LOG_PID,LOG_AUTH);
    vsyslog(LOG_DEBUG, fmt, va);
    closelog();
    
    va_end(va);
    
}

int spawn_server(const char* path, char*const* argv, char*const* envp)
{
    SYSLOG("spawn %s", path);
    for(int i=0; argv[i]; i++) {
        SYSLOG("argv[%d] %s", i, argv[i]);
    }
    
    __block pid_t pid=0;
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    
    posix_spawnattr_set_persona_np(&attr, 99, POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE);
    posix_spawnattr_set_persona_uid_np(&attr, 0);
    posix_spawnattr_set_persona_gid_np(&attr, 0);

    posix_spawn_file_actions_t action;
    posix_spawn_file_actions_init(&action);
    
    pipe(serverInputPipe);
    posix_spawn_file_actions_addclose(&action, serverInputPipe[1]);
    posix_spawn_file_actions_adddup2(&action, serverInputPipe[0], SERVER_INPUT_FD);
    posix_spawn_file_actions_addclose(&action, serverInputPipe[0]);
    
    pipe(serverOutputPipe);
    posix_spawn_file_actions_addclose(&action, serverOutputPipe[0]);
    posix_spawn_file_actions_adddup2(&action, serverOutputPipe[1], SERVER_OUTPUT_FD);
    posix_spawn_file_actions_addclose(&action, serverOutputPipe[1]);
    
    int outPipe[2];
    pipe(outPipe);
    posix_spawn_file_actions_addclose(&action, outPipe[0]);
    posix_spawn_file_actions_adddup2(&action, outPipe[1], STDOUT_FILENO);
    posix_spawn_file_actions_addclose(&action, outPipe[1]);
    
    int errPipe[2];
    pipe(errPipe);
    posix_spawn_file_actions_addclose(&action, errPipe[0]);
    posix_spawn_file_actions_adddup2(&action, errPipe[1], STDERR_FILENO);
    posix_spawn_file_actions_addclose(&action, errPipe[1]);
    
    dispatch_semaphore_t lock = dispatch_semaphore_create(0);
    
    dispatch_queue_t queue = dispatch_queue_create("spawnPipeQueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_source_t stdOutSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, outPipe[0], 0, queue);
    dispatch_source_t stdErrSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, errPipe[0], 0, queue);
    
    int outFD = outPipe[0];
    int errFD = errPipe[0];
    
    dispatch_source_set_cancel_handler(stdOutSource, ^{
        close(outFD);
        dispatch_semaphore_signal(lock);
        SYSLOG("stdout canceled [%d]", pid);
    });
    dispatch_source_set_cancel_handler(stdErrSource, ^{
        close(errFD);
        dispatch_semaphore_signal(lock);
        SYSLOG("stderr canceled [%d]", pid);
    });
    
    dispatch_source_set_event_handler(stdOutSource, ^{
        char buffer[BUFSIZ]={0};
        ssize_t bytes = read(outFD, buffer, sizeof(buffer)-1);
        if (bytes <= 0) {
            dispatch_source_cancel(stdOutSource);
            return;
        }
        SYSLOG("spawn[%d] stdout: %s", pid, buffer);
    });
    dispatch_source_set_event_handler(stdErrSource, ^{
        char buffer[BUFSIZ]={0};
        ssize_t bytes = read(errFD, buffer, sizeof(buffer)-1);
        if (bytes <= 0) {
            dispatch_source_cancel(stdErrSource);
            return;
        }
        SYSLOG("spawn[%d] stderr: %s", pid, buffer);
    });
    
    dispatch_resume(stdOutSource);
    dispatch_resume(stdErrSource);
    
    int spawnError = posix_spawn(&serverPid, path, &action, &attr, argv, envp);
    SYSLOG("spawn ret=%d, pid=%d", spawnError, pid);
    
    posix_spawnattr_destroy(&attr);
    posix_spawn_file_actions_destroy(&action);
    
    close(outPipe[1]);
    close(errPipe[1]);
    
    close(serverInputPipe[0]);
    close(serverOutputPipe[1]);
        
    if(spawnError != 0)
    {
        SYSLOG("posix_spawn error %d:%s", spawnError, strerror(spawnError));
        dispatch_source_cancel(stdOutSource);
        dispatch_source_cancel(stdErrSource);
        return spawnError;
    }
    
    return 0;
}

enum SERVER_CMD {
    GET_KSLIDE=1,
    KREAD_BUF,
    KWRITE_BUF,
    EXIT_SERVER,
};

int stop_server(void)
{
    uint32_t cmd = EXIT_SERVER;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    int status=0;
    while(waitpid(serverPid, &status, 0) != -1)
    {
        if (WIFSIGNALED(status)) {
            return 128 + WTERMSIG(status);
        } else if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        }
        //keep waiting?return status;
    };
    return -1;
}

uint64_t getkslide(void)
{
    uint32_t cmd = GET_KSLIDE;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    uint64_t kbase=0;
    read(serverOutputPipe[0], &kbase, sizeof(kbase));
    
    return kbase;
}

int temp_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    uint32_t cmd = KREAD_BUF;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    write(serverInputPipe[1], &kaddr, sizeof(kaddr));
    write(serverInputPipe[1], &size, sizeof(size));
    
    read(serverOutputPipe[0], output, size);
    
    int ret=0;
    read(serverOutputPipe[0], &ret, sizeof(ret));
    
    return ret;
}

int temp_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    uint32_t cmd = KWRITE_BUF;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    write(serverInputPipe[1], &kaddr, sizeof(kaddr));
    write(serverInputPipe[1], &size, sizeof(size));
    write(serverInputPipe[1], input, size);
    
    int ret=0;
    read(serverOutputPipe[0], &ret, sizeof(ret));
    
    return ret;
}

mach_port_t tfp0 = 0;

extern kern_return_t mach_vm_read_overwrite(task_t task, mach_vm_address_t addr, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(task_t task, mach_vm_address_t addr, mach_vm_address_t data, mach_msg_type_number_t dataCnt);

int tfp0_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    mach_vm_size_t read;
    return mach_vm_read_overwrite(tfp0, kaddr, size, (mach_vm_address_t)output, &read);
}

int tfp0_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    return mach_vm_write(tfp0, kaddr, (mach_vm_address_t)input, (mach_msg_type_number_t)size);
}

int exploit_init(const char *flavor)
{
    const char* server_path = NULL;
    
    const char* testserver = "/var/containers/Bundle/exploit_server";
    if(access(testserver, F_OK)==0) {
        server_path = testserver;
    } else {
        stdout_log = true;
        server_path = [NSBundle.mainBundle.bundlePath stringByAppendingPathComponent:@"Frameworks/palera1n.framework/exploit_server"].fileSystemRepresentation;
    }
    
    char*const args[] = {"exploit_server", "server", NULL};
    assert(spawn_server(server_path, args, environ) == 0);
    
    uint64_t kslide = getkslide();
    assert(kslide != 0);
    
    uint64_t kernelbase = kconstant(staticBase) + kslide;
    SYSLOG("kbase=%llx", kernelbase);
    
    gPrimitives.kwritebuf = temp_kwritebuf;
    gPrimitives.kreadbuf = temp_kreadbuf;
    gSystemInfo.kernelConstant.slide = kslide;
    
    SYSLOG("magic=%x", kread32(kernelbase));
    SYSLOG("kallproc=%llx", ksymbol(allproc));
    SYSLOG("allproc=%llx", kread64(ksymbol(allproc)));
    SYSLOG("launchd proc=%llx", proc_find(1));
/*
    uint64_t proc = proc_self();
    SYSLOG("proc=%llx", proc);
    uint64_t ucred = proc_ucred(proc);
    SYSLOG("ucred=%llx", ucred);
    
    // Get uid 0
    kwrite32(proc + koffsetof(proc, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, ruid), 0);
    kwrite32(ucred + koffsetof(ucred, uid), 0);
    
    // Get gid 0
    kwrite32(proc + koffsetof(proc, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, rgid), 0);
    kwrite32(ucred + koffsetof(ucred, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, groups), 0);
    
    // Add P_SUGID
    uint32_t flag = kread32(proc + koffsetof(proc, flag));
    if ((flag & P_SUGID) != 0) {
        flag &= P_SUGID;
        kwrite32(proc + koffsetof(proc, flag), flag);
    }
    
    stop_server();
    
    assert(getuid() == 0);
    assert(getgid() == 0);
    
    kern_return_t kr = task_for_pid(mach_task_self(), 0, &tfp0);
    SYSLOG("tfp0=%x, kr=%d(%s)", tfp0, kr, mach_error_string(kr));
    assert(kr == KERN_SUCCESS);
    
    gPrimitives.kwritebuf = tfp0_kwritebuf;
    gPrimitives.kreadbuf = tfp0_kreadbuf;
*/
    return 0;
}

int exploit_deinit(void)
{
/*
    if (gPrimitives.kreadbuf == tfp0_kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == tfp0_kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }
*/
    if (gPrimitives.kreadbuf == temp_kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == temp_kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }

    stop_server();

    return 0;
}
