#include <stdio.h>
#include <syslog.h>
#include <mach-o/loader.h>
#include <Foundation/Foundation.h>
#include <libjailbreak/libjailbreak.h>

#include <spawn.h>
#define POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 1
extern int posix_spawnattr_set_persona_np(const posix_spawnattr_t* __restrict, uid_t, uint32_t);
extern int posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t* __restrict, uid_t);
extern int posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t* __restrict, uid_t);

extern char*const* environ;

pid_t serverPid;
int serverInputPipe[2];
int serverOutputPipe[2];

#define SERVER_INPUT_FD 5
#define SERVER_OUTPUT_FD 6

bool stdout_log = false;
void SYSLOG(const char* fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    
    if(stdout_log) {
        vprintf(fmt, va);
    }
    
    openlog("palera1n",LOG_PID,LOG_AUTH);
    vsyslog(LOG_DEBUG, fmt, va);
    closelog();
    
    va_end(va);
    
}

int spawn_server(const char* path, char*const* argv, char*const* envp)
{
    SYSLOG("spawn %s", path);
    for(int i=0; argv[i]; i++) {
        SYSLOG("argv[%d] %s", i, argv[i]);
    }
    
    __block pid_t pid=0;
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    
    posix_spawnattr_set_persona_np(&attr, 99, POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE);
    posix_spawnattr_set_persona_uid_np(&attr, 0);
    posix_spawnattr_set_persona_gid_np(&attr, 0);

    posix_spawn_file_actions_t action;
    posix_spawn_file_actions_init(&action);
    
    pipe(serverInputPipe);
    posix_spawn_file_actions_addclose(&action, serverInputPipe[1]);
    posix_spawn_file_actions_adddup2(&action, serverInputPipe[0], SERVER_INPUT_FD);
    posix_spawn_file_actions_addclose(&action, serverInputPipe[0]);
    
    pipe(serverOutputPipe);
    posix_spawn_file_actions_addclose(&action, serverOutputPipe[0]);
    posix_spawn_file_actions_adddup2(&action, serverOutputPipe[1], SERVER_OUTPUT_FD);
    posix_spawn_file_actions_addclose(&action, serverOutputPipe[1]);
    
    int outPipe[2];
    pipe(outPipe);
    posix_spawn_file_actions_addclose(&action, outPipe[0]);
    posix_spawn_file_actions_adddup2(&action, outPipe[1], STDOUT_FILENO);
    posix_spawn_file_actions_addclose(&action, outPipe[1]);
    
    int errPipe[2];
    pipe(errPipe);
    posix_spawn_file_actions_addclose(&action, errPipe[0]);
    posix_spawn_file_actions_adddup2(&action, errPipe[1], STDERR_FILENO);
    posix_spawn_file_actions_addclose(&action, errPipe[1]);
    
    dispatch_semaphore_t lock = dispatch_semaphore_create(0);
    
    dispatch_queue_t queue = dispatch_queue_create("spawnPipeQueue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_source_t stdOutSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, outPipe[0], 0, queue);
    dispatch_source_t stdErrSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, errPipe[0], 0, queue);
    
    int outFD = outPipe[0];
    int errFD = errPipe[0];
    
    dispatch_source_set_cancel_handler(stdOutSource, ^{
        close(outFD);
        dispatch_semaphore_signal(lock);
        SYSLOG("stdout canceled [%d]", pid);
    });
    dispatch_source_set_cancel_handler(stdErrSource, ^{
        close(errFD);
        dispatch_semaphore_signal(lock);
        SYSLOG("stderr canceled [%d]", pid);
    });
    
    dispatch_source_set_event_handler(stdOutSource, ^{
        char buffer[BUFSIZ]={0};
        ssize_t bytes = read(outFD, buffer, sizeof(buffer)-1);
        if (bytes <= 0) {
            dispatch_source_cancel(stdOutSource);
            return;
        }
        SYSLOG("spawn[%d] stdout: %s", pid, buffer);
    });
    dispatch_source_set_event_handler(stdErrSource, ^{
        char buffer[BUFSIZ]={0};
        ssize_t bytes = read(errFD, buffer, sizeof(buffer)-1);
        if (bytes <= 0) {
            dispatch_source_cancel(stdErrSource);
            return;
        }
        SYSLOG("spawn[%d] stderr: %s", pid, buffer);
    });
    
    dispatch_resume(stdOutSource);
    dispatch_resume(stdErrSource);
    
    int spawnError = posix_spawn(&serverPid, path, &action, &attr, argv, envp);
    SYSLOG("spawn ret=%d, pid=%d", spawnError, pid);
    
    posix_spawnattr_destroy(&attr);
    posix_spawn_file_actions_destroy(&action);
    
    close(outPipe[1]);
    close(errPipe[1]);
    
    close(serverInputPipe[0]);
    close(serverOutputPipe[1]);
        
    if(spawnError != 0)
    {
        SYSLOG("posix_spawn error %d:%s", spawnError, strerror(spawnError));
        dispatch_source_cancel(stdOutSource);
        dispatch_source_cancel(stdErrSource);
        return spawnError;
    }
    
    return 0;
}

enum SERVER_CMD {
    GET_KSLIDE=1,
    KREAD_BUF,
    KWRITE_BUF,
    EXIT_SERVER,
};

int stop_server(void)
{
    uint32_t cmd = EXIT_SERVER;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    int status=0;
    while(waitpid(serverPid, &status, 0) != -1)
    {
        if (WIFSIGNALED(status)) {
            return 128 + WTERMSIG(status);
        } else if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        }
        //keep waiting?return status;
    };
    return -1;
}

uint64_t getkslide(void)
{
    uint32_t cmd = GET_KSLIDE;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    uint64_t kbase=0;
    read(serverOutputPipe[0], &kbase, sizeof(kbase));
    
    return kbase;
}

int temp_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    uint32_t cmd = KREAD_BUF;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    write(serverInputPipe[1], &kaddr, sizeof(kaddr));
    write(serverInputPipe[1], &size, sizeof(size));
    
    read(serverOutputPipe[0], output, size);
    
    int ret=0;
    read(serverOutputPipe[0], &ret, sizeof(ret));
    
    return ret;
}

int temp_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    uint32_t cmd = KWRITE_BUF;
    write(serverInputPipe[1], &cmd, sizeof(cmd));
    
    write(serverInputPipe[1], &kaddr, sizeof(kaddr));
    write(serverInputPipe[1], &size, sizeof(size));
    write(serverInputPipe[1], input, size);
    
    int ret=0;
    read(serverOutputPipe[0], &ret, sizeof(ret));
    
    return ret;
}

/* csops  operations */
#define	CS_OPS_STATUS		0	/* return status */
#define CS_PLATFORM_BINARY          0x04000000  /* this is a platform binary */
int csops(pid_t pid, unsigned int  ops, void * useraddr, size_t usersize);

int exploit_init(const char *flavor)
{
    uint32_t csFlags = 0;
    csops(getpid(), CS_OPS_STATUS, &csFlags, sizeof(csFlags));
    if((csFlags & CS_PLATFORM_BINARY)==0) {
        fprintf(stderr, "\n\n\n\n\n\n\n\n*** device is not booted with palera1n(roothide) ***\n\n\n\n\n\n\n\n");
        sleep(2);
        return -1;
    }

    const char* server_path = NULL;
    
    const char* testserver = "/var/containers/Bundle/exploit_server";
    if(access(testserver, F_OK)==0) {
        server_path = testserver;
    } else {
        stdout_log = true;
        server_path = [NSBundle.mainBundle.bundlePath stringByAppendingPathComponent:@"Frameworks/palera1n.framework/exploit_server"].fileSystemRepresentation;
    }
    
    char*const args[] = {"exploit_server", "server", NULL};
    int spawnError = spawn_server(server_path, args, environ);
    if(spawnError != 0) {
        fprintf(stderr, "\n\n\n\n\n\n\n\n*** Failed to spawn server: %d, %s ***\n\n\n\n\n\n\n\n", spawnError, strerror(spawnError));
        sleep(2);
        return -1;
    }
    
    uint64_t kslide = getkslide();
    if(kslide == 0) {
        fprintf(stderr, "\n\n\n\n\n\n\n\n*** Failed to get kslide ***\n\n\n\n\n\n\n\n");
        stop_server();
        sleep(2);
        return -1;
    }
    
    uint64_t kernelbase = kconstant(staticBase) + kslide;
    SYSLOG("kbase=%llx", kernelbase);

    uint32_t magic = 0;
    int r = temp_kreadbuf(kernelbase, &magic, sizeof(magic));
    if(magic != MH_MAGIC_64) {
        fprintf(stderr, "\n\n\n\n\n\n\n\n*** Invalid kernel magic %x @ %llx+%llx, ret=%d ***\n\n\n\n\n\n\n\n", magic, kconstant(staticBase), kslide, r);
        stop_server();
        sleep(2);
        return -1;
    }
    
    gPrimitives.kwritebuf = temp_kwritebuf;
    gPrimitives.kreadbuf = temp_kreadbuf;
    gSystemInfo.kernelConstant.slide = kslide;
    gSystemInfo.jailbreakInfo.palera1n = 'hide'; //use a magic value so we don't have to initialize it everywhere
    
    SYSLOG("magic=%x", kread32(kernelbase));
    SYSLOG("kallproc=%llx", ksymbol(allproc));
    SYSLOG("allproc=%llx", kread64(ksymbol(allproc)));
    SYSLOG("self proc=%llx", proc_find(getpid()));
    SYSLOG("launchd proc=%llx", proc_find(1));

    return 0;
}

int exploit_deinit(void)
{
    if (gPrimitives.kreadbuf == temp_kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == temp_kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }

    stop_server();

    return 0;
}
