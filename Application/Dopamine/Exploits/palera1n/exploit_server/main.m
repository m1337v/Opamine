#include <Foundation/Foundation.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <mach/mach.h>
#include <mach-o/loader.h>

#define SYSLOG(...) NSLog(@__VA_ARGS__)

mach_port_t g_tfp0 = 0;

extern kern_return_t mach_vm_read_overwrite(task_t task, mach_vm_address_t addr, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(task_t task, mach_vm_address_t addr, mach_vm_address_t data, mach_msg_type_number_t dataCnt);
extern kern_return_t mach_vm_allocate(task_t task, mach_vm_address_t *addr, mach_vm_size_t size, int flags);
extern kern_return_t mach_vm_deallocate(task_t task, mach_vm_address_t addr, mach_vm_size_t size);
kern_return_t mach_vm_region(vm_map_t, mach_vm_address_t *, mach_vm_size_t *, vm_region_flavor_t, vm_region_info_t, mach_msg_type_number_t *, mach_port_t *);

kern_return_t kread_buf(uint64_t addr, void *buf, mach_vm_size_t sz) {
        mach_vm_size_t readlen = sz;
        return mach_vm_read_overwrite(g_tfp0, addr, sz, (mach_vm_address_t)buf, &readlen);
}
kern_return_t kwrite_buf(uint64_t addr, void *buf, mach_vm_size_t sz) {
        return mach_vm_write(g_tfp0, addr, (mach_vm_address_t)buf, sz);
}

kern_return_t kread_addr(uint64_t addr, uint64_t *val) {
	return kread_buf(addr, val, sizeof(*val));
}


#define LZSS_F (18)
#define LZSS_N (4096)
#define LZSS_THRESHOLD (2)
#define IPC_ENTRY_SZ (0x18)
#define OS_STRING_LEN_OFF (0xC)
#define KCOMP_HDR_PAD_SZ (0x16C)
#define OS_STRING_STRING_OFF (0x10)
#define IPC_SPACE_IS_TABLE_OFF (0x20)
#define IPC_ENTRY_IE_OBJECT_OFF (0x0)
#define PROC_P_LIST_LE_PREV_OFF (0x8)
#define OS_DICTIONARY_COUNT_OFF (0x14)
#define IPC_PORT_IP_KOBJECT_OFF (0x68)
#define PROC_P_LIST_LH_FIRST_OFF (0x0)
#define IPC_SPACE_IS_TABLE_SZ_OFF (0x14)
#define OS_DICTIONARY_DICT_ENTRY_OFF (0x20)
#define OS_STRING_LEN(a) extract32(a, 14, 18)
#define LOADED_KEXT_SUMMARY_HDR_NAME_OFF (0x10)
#define LOADED_KEXT_SUMMARY_HDR_ADDR_OFF (0x60)
#define APPLE_MOBILE_AP_NONCE_CLEAR_NONCE_SEL (0xC9)
#define APPLE_MOBILE_AP_NONCE_GENERATE_NONCE_SEL (0xC8)

#define KADDR_FMT "0x%" PRIX64
#define VM_KERN_MEMORY_OSKEXT (5)
#define kOSBundleLoadAddressKey "OSBundleLoadAddress"

CFDictionaryRef
OSKextCopyLoadedKextInfo(CFArrayRef, CFArrayRef);

uint64_t getkslide() {

    uint64_t kslide = 0;

	vm_region_extended_info_data_t extended_info;
	CFDictionaryRef kexts_info, kext_info;
	task_dyld_info_data_t dyld_info;
	char kext_name[KMOD_MAX_NAME]={0};
	struct mach_header_64 mh64;
	CFStringRef kext_name_cf;
	CFNumberRef kext_addr_cf;
	mach_port_t object_name;
	CFArrayRef kext_names;

	uint32_t cnt = VM_REGION_EXTENDED_INFO_COUNT;
	uint64_t addr=0, kext_addr=0, kext_addr_slid=0;
	mach_vm_size_t sz=0;

    for(addr = 0; mach_vm_region(g_tfp0, &addr, &sz, VM_REGION_EXTENDED_INFO, (vm_region_info_t)&extended_info, &cnt, &object_name) == KERN_SUCCESS; addr += sz) {
        mach_port_deallocate(mach_task_self(), object_name);
        
        if(extended_info.protection == VM_PROT_READ && extended_info.user_tag == VM_KERN_MEMORY_OSKEXT) {

            // printf("addr=%llx, sz=%llx, protection=%x, user_tag=%x\n", addr, sz, extended_info.protection, extended_info.user_tag);

            if(kread_buf(addr + LOADED_KEXT_SUMMARY_HDR_NAME_OFF, kext_name, sizeof(kext_name)) == KERN_SUCCESS) {
                // printf("kext_name: %s\n", kext_name);
                if(kread_addr(addr + LOADED_KEXT_SUMMARY_HDR_ADDR_OFF, &kext_addr_slid) == KERN_SUCCESS) {
                    // printf("kext_addr_slid: " KADDR_FMT "\n", kext_addr_slid);
                    if((kext_name_cf = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, kext_name, kCFStringEncodingUTF8, kCFAllocatorNull)) != NULL) {
                        if((kext_names = CFArrayCreate(kCFAllocatorDefault, (const void **)&kext_name_cf, 1, &kCFTypeArrayCallBacks)) != NULL) {
                            if((kexts_info = OSKextCopyLoadedKextInfo(kext_names, NULL)) != NULL) {
                                // SYSLOG("kexts_info=%@", kexts_info);
                                if(CFGetTypeID(kexts_info) == CFDictionaryGetTypeID() 
                                && CFDictionaryGetCount(kexts_info) == 1 
                                && (kext_info = CFDictionaryGetValue(kexts_info, kext_name_cf)) != NULL 
                                && CFGetTypeID(kext_info) == CFDictionaryGetTypeID() 
                                && (kext_addr_cf = CFDictionaryGetValue(kext_info, CFSTR(kOSBundleLoadAddressKey))) != NULL 
                                && CFGetTypeID(kext_addr_cf) == CFNumberGetTypeID() 
                                && CFNumberGetValue(kext_addr_cf, kCFNumberSInt64Type, &kext_addr) 
                                && kext_addr_slid > kext_addr) {
                                    
                                    kslide = kext_addr_slid - kext_addr;
                                    // printf("kext_addr_slid=%llx, kext_addr=%llx\n", kext_addr_slid, kext_addr);
                                    // printf("kslide=%llx\n", kslide);
                                }
                                CFRelease(kexts_info);
                            }
                            CFRelease(kext_names);
                        }
                        CFRelease(kext_name_cf);
                    }
                }
            }
            break;
        }
    }

    return kslide;
}

enum SERVER_CMD {
    GET_KSLIDE=1,
    KREAD_BUF,
    KWRITE_BUF,
    EXIT_SERVER,
};

#define SERVER_INPUT_FD 5
#define SERVER_OUTPUT_FD 6

int main( int argc, char** argv)
{
    assert(getuid() == 0);
    
    kern_return_t kr;
    kr = task_for_pid(mach_task_self(), 0, &g_tfp0);
    assert(kr == KERN_SUCCESS);

    if(argc==2 && strcmp(argv[1], "server")==0) 
    {
        while(true)
        {
            uint32_t cmd=0;
            int ret = read(SERVER_INPUT_FD, &cmd, sizeof(cmd));
            SYSLOG("cmd=%d, ret=%d,%d,%s", cmd, ret, errno, strerror(errno));
            switch(cmd) {
                case GET_KSLIDE: {
                    uint64_t kslide = getkslide();
                    write(SERVER_OUTPUT_FD, &kslide, sizeof(kslide));
                    break;
                }

                case KREAD_BUF: {
                    uint64_t addr=0;
                    size_t size=0;
                    read(SERVER_INPUT_FD, &addr, sizeof(addr));
                    read(SERVER_INPUT_FD, &size, sizeof(size));
                    SYSLOG("addr=%llx, size=%lx", addr, size);
                    void *buf = malloc(size);
                    int ret = kread_buf(addr, buf, size);
                    write(SERVER_OUTPUT_FD, buf, size);
                    write(SERVER_OUTPUT_FD, &ret, sizeof(ret));
                    free(buf);
                    break;
                }

                case KWRITE_BUF: {
                    uint64_t addr=0;
                    size_t size=0;
                    read(SERVER_INPUT_FD, &addr, sizeof(addr));
                    read(SERVER_INPUT_FD, &size, sizeof(size));
                    SYSLOG("addr=%llx, size=%lx", addr, size);
                    void *buf = malloc(size);
                    read(SERVER_INPUT_FD, buf, size);
                    int ret = kwrite_buf(addr, buf, size);
                    write(SERVER_OUTPUT_FD, &ret, sizeof(ret));
                    free(buf);
                    break;
                }

                case EXIT_SERVER: {
                    return 0;
                }

                default:
                    SYSLOG("unknown cmd %d", cmd);
                    abort();
                    return -1;
            }
        }
    }

    uint64_t kslide = getkslide();
    printf("kslide=%llx\n", kslide);
    uint64_t kbase = 0xfffffff007004000 + kslide;

    uint32_t magic=0;
    kread_buf(kbase, &magic, sizeof(magic));
    printf("magic=%x\n", magic);

    return 0;    
}
